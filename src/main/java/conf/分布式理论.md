#分布式理论
首先说两个概念：

- 分布式： 一个业务分拆多个子业务，部署在不同的服务器上
- 集群： 同一个业务，部署在多个服务器上。比如之前做电商网站搭的redis集群以及solr集群都是属于将redis服务器提供的缓存服务以及solr服务器提供的搜索服务部署在多个服务器上以提高系统性能、并发量解决海量存储问题。

##目标与要素
分布式系统的目标是提升系统的整体性能和吞吐量另外还要尽量保证分布式系统的容错性。
采用了分布式，就要在单机上尽力运行并发编程、高性能网络框架等手段提升单机性能。

##两大思路

- 中心化  ：如master与slave模式
-去中心化 ：如zk、etcd。由节点自由的选择中心。会有脑裂问题

#CAP

- 一致性（Consistence） :所有节点访问同一份最新的数据副本
- 可用性（Availability）:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据
- 分区容错性（Partition tolerance） : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

CAP理论适用于NoSql的原子读写，场景，不适合数据库系统。现在的分布式系统具有更多的特性如扩展性、可用性等。

#Base

- BASE 是 Basically Available（基本可用） 
- Soft-state（软状态） 
- Eventually Consistent（最终一致性）

    
#分布式锁
三种实现方式

##1.zookeeper实现分布式锁
总体思路：
    用zk的临时顺序节点的特性，客户端会话失效节点就会消失。
    
流程：

1. 获取分布式锁时在Lock节点下创建临时顺序节点，释放锁的时候删除该临时节点。
2. 客户端调用createNode方法在Lock节点下创建临时顺序节点。然后调用getChildren获取所有子节点。
    1. 如果发现当前自己创建的节点的序号是最小的话，就认定该客户端获取到锁。
    2. 如果发现不是最小的节点。说明获取锁失败，此时客户端需要找到比自己小的节点，对其注册事件监听器。
3.  当前获取到锁的客户端删除当前最小节点，那么注册过事件监听器的客户端会收到通知，此时再次判断是否自己的节点是最小的，
    是的话直接获取到锁，不是的话重复步骤监听比自己小的节点的事件。

解决的问题：

1. 锁无法释放？
    客户端获得到锁之后突然挂掉，临时节点就会自动删除，其他客户端可以再次获得锁。
2. 非阻塞？
    可以实现阻塞的锁，客户端可以再zk中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户
    端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。
3. 不可重入？
    客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的
    时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。         
4. 单点问题？
    ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。   
                            
    


 